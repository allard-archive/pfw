<table class="manual" id="basic" style="width: 70%;">
  <caption>traffic normalization</caption>
  <tr>
    <th>Statement</th>
    <th>Description</th>
  </tr>
  <tr>
    <td colspan="2">
      Traffic normalization is used to sanitize packet content in such a way
      that there are no ambiguities in packet interpretation on the receiving
      side.  The normalizer does IP fragment reassembly to prevent attacks that
      confuse intrusion detection systems by sending overlapping IP fragments.
      Packet normalization is invoked with the scrub directive.</td>
  </tr>
  <tr>
    <td nowrap="nowrap">no-df</td>
    <td>
      <p>Clears the dont-fragment bit from a matching IP packet.  Some 
         operating systems are known to generate fragmented packets with the
         dont-fragment bit set.  This is particularly true with NFS.  Scrub
         will drop such fragmented dont-fragment packets unless no-df is
         specified.</p>

      <p>Unfortunately some operating systems also generate their dont-
      fragment packets with a zero IP identification field.  Clearing the
      dont-fragment bit on packets with a zero IP ID may cause deleterious 
      results if an upstream router later fragments the packet.  Using 
      the random-id modifier (see below) is recommended in combination 
      with the no-df modifier to ensure unique IP identifiers.</p>
    </td>
  </tr>
  <tr>
    <td nowrap="nowrap">min-ttl <strong>number</strong></td>
    <td>Enforces a minimum TTL for matching IP packets.</td>
  </tr>
  <tr>
    <td nowrap="nowrap">max-mss <strong>number</strong></td>
    <td>Enforces a maximum MSS for matching TCP packets.</td>
  </tr>
  <tr>
    <td nowrap="nowrap">random-id</td>
    <td>Replaces the IP identification field with random values to compensate 
        for predictable values generated by many hosts.  This option
        only applies to outgoing packets that are not fragmented after the
        optional fragment reassembly.</td>
  </tr>
  <tr>
    <td nowrap="nowrap">fragment reassemble</td>
    <td>Using scrub rules, fragments can be reassembled by normalization.
        In this case, fragments are buffered until they form a complete
        packet, and only the completed packet is passed on to the filter.
        The advantage is that filter rules have to deal only with complete
        packets, and can ignore fragments.  The drawback of caching fragments 
        is the additional memory cost.  But the full reassembly
        method is the only method that currently works with NAT. This is
        the default behavior of a scrub rule if no fragmentation modifier
        is supplied.
    </td>
  </tr>
  <tr>
    <td nowrap="nowrap">fragment crop</td>
    <td>The default fragment reassembly method is expensive, hence the option 
        to crop is provided.  In this case, pf(4) will track the fragments 
        and cache a small range descriptor.  Duplicate fragments are
        dropped and overlaps are cropped.  Thus data will only occur once
        on the wire with ambiguities resolving to the first occurrence.
        Unlike the fragment reassemble modifier, fragments are not
        buffered, they are passed as soon as they are received.  The
        fragment crop reassembly mechanism does not yet work with NAT.</td>
  </tr>
  <tr>
    <td nowrap="nowrap">fragment drop-ovl</td>
    <td>
      This option is similar to the fragment crop modifier except that
      all overlapping or duplicate fragments will be dropped, and all
      further corresponding fragments will be dropped as well.</td>
  </tr>
  <tr>
    <td nowrap="nowrap">reassemble tcp</td>
    <td>
      <p>Statefully normalizes TCP connections.  scrub reassemble tcp rules
         may not have the direction (in/out) specified.  reassemble tcp performs 
         the following normalizations:</p>
        <table>
          <tr>
            <td class="key">ttl</td>
            <td>Neither side of the connection is allowed to reduce their
               IP TTL.  An attacker may send a packet such that it reaches 
               the firewall, affects the firewall state, and expires
               before reaching the destination host.  reassemble tcp will
               raise the TTL of all packets back up to the highest value
               seen on the connection.</td>
          </tr>
          <tr>
            <td class="key">timeout modulation</td>
            <td>Modern TCP stacks will send a timestamp on every TCP packet 
                and echo the other endpoint's timestamp back to them.
                Many operating systems will merely start the timestamp at
                zero when first booted, and increment it several times a
                second.  The uptime of the host can be deduced by reading
                the timestamp and multiplying by a constant.  Also observing 
                several different timestamps can be used to count
                hosts behind a NAT device.  And spoofing TCP packets into
                a connection requires knowing or guessing valid timestamps.
                Timestamps merely need to be monotonically increasing and 
                not derived off a guessable base time.
                reassemble tcp will cause scrub to modulate the TCP timestamps 
                with a random number.</td>
          </tr>
          <tr>
            <td class="key">extended PAWS checks</td>
            <td>There is a problem with TCP on long fat pipes, in that a
                packet might get delayed for longer than it takes the 
                connection to wrap its 32-bit sequence space.  In such an 
                occurance, the old packet would be indistinguishable from a
                new packet and would be accepted as such.  The solution to
                this is called PAWS: Protection Against Wrapped Sequence
                numbers.  It protects against it by making sure the timestamp 
                on each packet does not go backwards.  reassemble tcp
                also makes sure the timestamp on the packet does not go
                forward more than the RFC allows.  By doing this, pf(4)
                artificially extends the security of TCP sequence numbers
                by 10 to 18 bits when the host uses appropriately randomized 
                timestamps, since a blind attacker would have to
                guess the timestamp as well.
            </td>
          </tr>
        </table>
    </td>
  </tr>
  <tr>
    <td colspan="2">
      <p>For example,</p>
      
      <code>scrub in on $ext_if all fragment reassemble</code>
    </td>
  </tr>
</table>

